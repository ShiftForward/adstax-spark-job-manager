#!/usr/bin/env ruby

require 'file-tail'
require 'json'
require 'net/http'
require 'optparse'
require 'tempfile'

# -----------------
# Constants
# -----------------

MAIN_CLASS = 'eu.shiftforward.adstax.spark.SparkJobRunner'
SPARK_EXECUTOR_URI = 'https://s3.amazonaws.com/shiftforward-public/bin/spark/spark-2.0.0-SNAPSHOT-bin-2.4.0.tgz'
SPARK_SCALA_VERSION = '2.11' # TODO: Support other versions and use different executors

# -----------------
# CLI arguments parsing
# -----------------

$cli_args = {
  :follow => false
}

ARGV << '-h' if ARGV.empty?

OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} <action> --adstax-host <adstax_host> [<options>]"
  opts.separator ''
  opts.separator 'Submit, kill, query the status, or inspect the log of a Spark job running in an AdStax cluster.'
  opts.separator "<action> is one of 'submit', 'kill', 'status' or 'log'."
  opts.separator "Example: #{$0} submit --adstax-host sample-adstax-instance.dev.adstax.io --jar http://s3.amazonaws.com/shiftforward-public/bin/spark/adstax-spark-examples.jar --job eu.shiftforward.adstax.spark.examples.SparkPi 1000"
  opts.separator "Example: #{$0} kill driver-20160420105830-0001"
  opts.separator ''
  opts.separator 'Options:'

  opts.on('--adstax-host STRING', 'Host suffix to the AdStax cluster services.') do |host_suffix|
    $cli_args[:host_suffix] = host_suffix
  end

  opts.on('--jar STRING',
          'Path to a bundled jar including your application and all dependencies.',
          'The URL must be globally visible inside of your cluster.') do |jar|
    $cli_args[:jar] = jar
  end

  opts.on('--job STRING',
          'Fully qualified name of the class extending `eu.shiftforward.adstax.spark.SparkJob`.',
          'The class will be used as the Spark job to run.') do |job|
    $cli_args[:job] = job
  end

  opts.on('--submission-id STRING',
          'Id of the submission (required for the kill, status and log actions).') do |submission_id|
    $cli_args[:submission_id] = submission_id
  end

  opts.on('--follow',
          "Enables following the file updates in the 'log' action.") do |f|
    $cli_args[:follow] = f
  end

  opts.on_tail('-h', '--help', 'Show this message.') do
    puts opts
    exit
  end
end.parse!

def warn_missing(name)
  puts "Missing required argument: #{name}"
  exit 1
end

def get_http(uri)
  uri = URI.parse(uri)
  Net::HTTP.new(uri.host, uri.port)
end

def get_task(state_response, task_id)
  target_tasks = []
  state_response['completed_frameworks'].concat(state_response['frameworks']).each do |framework|
    framework['completed_tasks'].concat(framework['tasks']).each do |task|
      if (task['id']== task_id)
        target_tasks.push(task)
      end
    end
  end
  target_tasks[0]
end

def get_executor(state_response, task_id)
  target_executors = []
  state_response['completed_frameworks'].concat(state_response['frameworks']).each do |framework|
    framework['completed_executors'].concat(framework['executors']).each do |executor|
      if (executor['id'] == task_id)
        target_executors.push(executor)
      end
    end
  end
  target_executors[0]
end

def mesos_download(http, remote_file, local_file)
  params = { :path => remote_file }
  encoded_params = URI.encode_www_form(params)
  file_response = http.request(Net::HTTP::Get.new(["/files/download", encoded_params].join('?')))
  if (!file_response.class.body_permitted?)
    puts "Unable to fetch file from slave"
    exit 1
  end
  local_file.rewind
  local_file.write(file_response.body)
end

$action = ARGV.shift || begin
  warn_missing('action')
end

warn_missing('--adstax-host') unless $cli_args[:host_suffix]
$cluster_dispatcher_host = "http://spark-cluster-dispatcher.#{$cli_args[:host_suffix]}:7077"

# -----------------
# Program start
# -----------------

case $action
when 'submit'
  warn_missing('--jar') unless $cli_args[:jar]
  warn_missing('--job') unless $cli_args[:job]
  uri = URI.parse($cluster_dispatcher_host)
  http = Net::HTTP.new(uri.host, uri.port)
  payload = {
    'action' => 'CreateSubmissionRequest',
    'appArgs' => ['--job', $cli_args[:job]].concat(ARGV),
    'appResource' => $cli_args[:jar],
    'mainClass' => MAIN_CLASS,
    'clientSparkVersion' => '1.6.1',
    'environmentVariables' => {
      'SPARK_SCALA_VERSION' => SPARK_SCALA_VERSION
    },
    'sparkProperties' => {
      'spark.jars' => $cli_args[:jar],
      'spark.driver.supervise' => 'false',
      'spark.app.name' => MAIN_CLASS,
      'spark.es.port' => '49200',
      'spark.es.nodes' => 'localhost',
      'spark.submit.deployMode' => 'cluster',
      'spark.mesos.coarse' => 'false',
      'spark.master' => "mesos://spark-cluster-dispatcher.#{$cli_args[:host_suffix]}:7077",
      'spark.executor.uri' => SPARK_EXECUTOR_URI
    }
  }.to_json
  request = Net::HTTP::Post.new(
    '/v1/submissions/create',
    initheader = { 'Content-Type' => 'application/json' })
  request.body = payload
  response = http.request(request)
  puts response.body

when 'kill'
  warn_missing('--submission_id') unless $cli_args[:submission_id]
  uri = URI.parse($cluster_dispatcher_host)
  http = Net::HTTP.new(uri.host, uri.port)
  request = Net::HTTP::Post.new("/v1/submissions/kill/#{$cli_args[:submission_id]}")
  response = http.request(request)
  puts response.body

when 'status'
  warn_missing('--submission_id') unless $cli_args[:submission_id]
  uri = URI.parse($cluster_dispatcher_host)
  http = Net::HTTP.new(uri.host, uri.port)
  request = Net::HTTP::Get.new("/v1/submissions/status/#{$cli_args[:submission_id]}")
  response = http.request(request)
  puts response.body

when 'log'
  warn_missing('--submission_id') unless $cli_args[:submission_id]
  marathon_http = get_http("http://marathon.#{$cli_args[:host_suffix]}")
  marathon_response = marathon_http.request(Net::HTTP::Get.new("/v2/info"))
  if (!marathon_response.class.body_permitted?)
    puts "Unable to fetch Mesos leader url from Marathon"
    exit 1
  end
  res = JSON.parse(marathon_response.body)
  mesos_http = get_http(res['marathon_config']['mesos_leader_ui_url'])
  mesos_response = mesos_http.request(Net::HTTP::Get.new("/state.json"))
  if (!mesos_response.class.body_permitted?)
    puts "Unable to fetch Mesos status"
    exit 1
  end
  res = JSON.parse(mesos_response.body)
  target_task = get_task(res, $cli_args[:submission_id])
  if (!target_task)
    puts "Unable to find submission with id #{$cli_args[:submission_id]}"
    exit 1
  end
  slaves = res['slaves']
  slave_id = target_task['slave_id']
  target_slaves = slaves.select do |slave|
    slave['id'] == slave_id
  end
  if (target_slaves.length == 0)
    puts "Unable to find slave with id #{slave_id}"
    exit 1
  end
  if (target_slaves.length != 1)
    puts "Multiple slaves with id #{slave_id}"
    exit 1
  end
  target_slave = target_slaves[0]
  slave_http = get_http('http://' + target_slave['hostname'] + ':5051')
  slave_response = slave_http.request(Net::HTTP::Get.new("/state.json"))
  if (!slave_response.class.body_permitted?)
    puts "Unable to fetch file from slave"
    exit 1
  end
  res = JSON.parse(slave_response.body)
  target_executor = get_executor(res, $cli_args[:submission_id])
  if (!target_executor)
    puts "Unable to find submission with id #{$cli_args[:submission_id]}"
    exit 1
  end
  directory = target_executor['directory']
  file = Tempfile.new('spark' + $cli_args[:submission_id])

  download_thread = nil
  if ($cli_args[:follow])
    download_thread = Thread.new {
      loop {
        begin
          sleep 1
        rescue SignalException => e
          exit 1
        end
        mesos_download(slave_http, directory + '/stdout', file)
      }
    }
  else
    mesos_download(slave_http, directory + '/stdout', file)
  end
  if ($cli_args[:follow])
    File.open(file.path) do |log|
      log.extend(File::Tail)
      log.interval = 1
      log.backward(10)
      log.tail { |line| puts line }
    end
  else
    file.rewind
    puts file.read
  end

else
  puts "Unrecognized action: #{$action}"
  exit 1
end
